# dict set 的实现及其后果

- [dict set 的实现及其后果](#dict-set-的实现及其后果)
  - [dict的实现及其后果](#dict的实现及其后果)
    - [键必须是可散列的](#键必须是可散列的)
    - [字典在内存上开销巨大](#字典在内存上开销巨大)
    - [键查询很快](#键查询很快)
    - [键的次序取决于添加顺序](#键的次序取决于添加顺序)
    - [往字典添加新键可能会改变已有键的顺序](#往字典添加新键可能会改变已有键的顺序)
  - [set的实现及其后果](#set的实现及其后果)

---

## dict的实现及其后果

### 键必须是可散列的

一个可散列的对象必须满足一下要求：

- 支持`hash()`函数，并且通过`__hash__()`方法所得到的散列值是不变的。
- 支持通过`__eq__()`方法来检测相等性
- 若`a == b`为真，则`hash(a) == hash(b)`也为真

所有用户自定义的对象都是可散列的，因为它们的散列值由`id()`来获取，而且它们是不相等的。

如果你实现了一个类的`__eq__`方法，并希望它是可散列的，那么它一定要有一个恰当的`__hash__`方法，保证`a == b`为真的情况下`hash(a) == hash(b)`也必定为真。
否则就会破坏恒定的散列表算法，导致这些对象所组成的字典和集合失去可靠性！
另一方面，如果一个含有自定义的`__eq__`依赖的类处于可变的状态，那就不要在这个类中实现`__hash__`方法，因为它的实例是不可散列的！

---

### 字典在内存上开销巨大

字典使用了散列表，散列表必须是稀疏的，这导致它在空间上的效率低下。
如果需要存放数据量巨大的记录，那么放在由元组或是具名元组构成的列表中会是更好的选择；最好不要JSON风格（由字典组成的列表风格）。

用元组取代有两个好处：

- 避免散列表耗费的空间；
- 无需把记录中字段的名字在每个元素里都村一遍

在用户自定义的类型中，`__slots__`属性可以改变实例属性的存储方式。

但是如果没有必要的话（内存足够）并不需要这样做，优化往往是可维护性的对立面。

---

### 键查询很快

典型的以空间换时间。巨大的内存开销换取的是无视数据量的快速访问——只要数据在内存里。

---

### 键的次序取决于添加顺序

dict里添加新键而又发生散列冲突的时候，新键可能会被安排存放在一个新的位置。于是可能会出现两个字典虽然相等但是键的位置不相等的情况。

---

### 往字典添加新键可能会改变已有键的顺序

无论何时往字典添加新的键，python解释器都可能做出为字典扩容的决定。
扩容导致要新建一个更大的散列表，并把字典里已有的元素添加到新表里面。这个过程可能会导致散列冲突，导致新表中键的次序发生变化。

如果你在迭代一个字典的所有键的过程中同时对字典进行修改，那么这个循环很可能会跳过一些键——甚至跳过那些字典中已有的键。
**所以不要对字典同时迭代和修改。如果要扫描修改一个字典，最好分成两步进行：首先对字典迭代，得出需要添加的内容，把这些内容放在一个新的字典里；迭代结束之后在对原字典进行更新。**

---

## set的实现及其后果

同样是散列，和dict一样。
